import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

public class TicketValidator {
    private List<Ticket> databaseTickets; // Assume this gets initialized elsewhere

    public TicketValidator(List<Ticket> databaseTickets) {
        this.databaseTickets = databaseTickets;
    }

    public List<Ticket> validateTickets(List<Ticket> inputTickets, String ticketType) {
        // Combine database tickets with input tickets for 'adjustment' type, excluding soft-deleted ones
        List<Ticket> allTickets = ticketType.equals("adjustment") ?
                Stream.concat(databaseTickets.stream(), inputTickets.stream())
                        .filter(ticket -> !inputTickets.contains(ticket) || !databaseTickets.contains(ticket)) // Exclude soft-deleted
                        .collect(Collectors.toList()) :
                new ArrayList<>(inputTickets); // For 'migration', use only input tickets

        // Aggregate TP amounts
        Map<String, BigDecimal> aggregatedTpAmounts = aggregateTpAmounts(allTickets);

        // Identify invalid combinations
        Set<String> invalidCombinations = identifyInvalidCombinations(aggregatedTpAmounts);

        // Determine invalid tickets based on invalid combinations
        return inputTickets.stream()
                .filter(ticket -> invalidCombinations.contains(ticket.getCombination()))
                .collect(Collectors.toList());
    }

    private Map<String, BigDecimal> aggregateTpAmounts(List<Ticket> tickets) {
        return tickets.stream()
                .collect(Collectors.toMap(
                        ticket -> generateAggregationKey(ticket),
                        ticket -> BigDecimal.valueOf(ticket.getTpAmount()).setScale(2, BigDecimal.ROUND_HALF_UP),
                        BigDecimal::add));
    }

    private String generateAggregationKey(Ticket ticket) {
        return ticket.getCombination() + "#" + ticket.getTFD();
    }

    private Set<String> identifyInvalidCombinations(Map<String, BigDecimal> aggregatedTpAmounts) {
        Set<String> combinations = aggregatedTpAmounts.keySet().stream()
                .map(key -> key.substring(0, key.lastIndexOf("#")))
                .collect(Collectors.toSet());

        return combinations.stream()
                .filter(combination -> {
                    boolean hasMF = aggregatedTpAmounts.containsKey(combination + "#MF") && 
                                      aggregatedTpAmounts.get(combination + "#MF").compareTo(BigDecimal.ZERO) > 0;
                    boolean hasPFON = aggregatedTpAmounts.containsKey(combination + "#PFON") && 
                                      aggregatedTpAmounts.get(combination + "#PFON").compareTo(BigDecimal.ZERO) > 0;
                    return hasMF && hasPFON;
                })
                .collect(Collectors.toSet());
    }
}
